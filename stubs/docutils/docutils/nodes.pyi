from pathlib import Path
from typing import Any, Callable, Dict, Iterable, List, Optional, Sequence, Tuple, Union, overload

from docutils.transforms import Transform, Transformer

__docformat__: str
unicode = str
basestring = str

class _traversal_list(list):
    done: bool

class Node:
    parent: Optional[Node]
    document: Optional[document]
    source: Union[Path, str, None]
    line: Optional[int]
    def __bool__(self) -> bool: ...
    def pformat(self, indent: str = ..., level: int = ...) -> str: ...
    def copy(self) -> Node: ...
    def deepcopy(self) -> Node: ...
    def astext(self) -> str: ...
    def setup_child(self, child: Node) -> None: ...
    def walk(self, visitor: NodeVisitor) -> bool: ...
    def walkabout(self, visitor: NodeVisitor) -> bool: ...
    def traverse(
        self,
        condition: Union[Callable[[Node], bool], Node, None] = ...,
        include_self: bool = ...,
        descend: bool = ...,
        siblings: bool = ...,
        ascend: bool = ...,
    ): ...
    def next_node(
        self,
        condition: Union[Callable[[Node], bool], Node, None] = ...,
        include_self: bool = ...,
        descend: bool = ...,
        siblings: bool = ...,
        ascend: bool = ...,
    ): ...

reprunicode = unicode

def ensure_str(s: unicode) -> str: ...
def unescape(text: str, restore_backslashes: bool = ..., respect_whitespace: bool = ...) -> str: ...

class Text(Node, reprunicode):
    tagname: str
    children: Tuple[()]
    def __new__(cls, data: str, rawsource: Optional[Any] = ...) -> Text: ...
    rawsource: str
    def __init__(self, data: str, rawsource: str = ...) -> None: ...
    def shortrepr(self, maxlen: int = ...) -> str: ...
    def astext(self) -> str: ...
    def copy(self) -> Text: ...
    def deepcopy(self) -> Text: ...
    def pformat(self, indent: str = ..., level: int = ...) -> str: ...
    def rstrip(self, chars: Optional[str] = ...) -> Text: ...
    def lstrip(self, chars: Optional[str] = ...) -> Text: ...

class Element(Node):
    basic_attributes: Tuple[str, ...]
    local_attributes: Tuple[str, ...]
    list_attributes: Tuple[str, ...]
    known_attributes: Tuple[str, ...]
    tagname: Optional[str] = ...
    child_text_separator: str = ...
    rawsource: str = ...
    children: Sequence[Node] = ...
    attributes: Dict[str, Any] = ...
    def __init__(self, rawsource: str = ..., *children: Iterable[Node], **attributes: Dict[str, Any]) -> None: ...
    def shortrepr(self) -> str: ...
    def __unicode__(self) -> str: ...
    def starttag(self, quoteattr: Optional[str] = ...) -> str: ...
    def endtag(self) -> str: ...
    def emptytag(self) -> str: ...
    def __len__(self) -> int: ...
    @overload
    def __getitem__(self, key: basestring) -> Any: ...
    @overload
    def __getitem__(self, key: int) -> Node: ...
    @overload
    def __getitem__(self, key: slice) -> Iterable[Node]: ...
    @overload
    def __setitem__(self, key: basestring, item: Any) -> None: ...
    @overload
    def __setitem__(self, key: int, item: Node) -> None: ...
    @overload
    def __setitem__(self, key: slice, item: Iterable[Node]) -> None: ...
    def __delitem__(self, key: Union[basestring, int, slice]) -> None: ...
    def __add__(self, other: Union[Node, Iterable[Node]]): ...
    def __radd__(self, other: Union[Node, Iterable[Node]]): ...
    def __iadd__(self, other: Union[Node, Iterable[Node]]) -> Element: ...
    def astext(self) -> str: ...
    def non_default_attributes(self) -> Dict[str, Any]: ...
    def attlist(self) -> list: ...
    def get(self, key: str, failobj: Optional[Any] = ...) -> Any: ...
    def hasattr(self, attr: str) -> bool: ...
    def delattr(self, attr: str) -> None: ...
    def setdefault(self, key: Any, failobj: Optional[Any] = ...) -> Any: ...
    has_key: Callable[[str], bool]
    def __contains__(self, key: str) -> bool: ...
    def get_language_code(self, fallback: str = ...) -> str: ...
    def append(self, item: Node) -> None: ...
    def extend(self, item: Iterable[Node]) -> None: ...
    def insert(self, index: int, item: Node) -> None: ...
    def pop(self, i: int = ...) -> Node: ...
    def remove(self, item: Node) -> None: ...
    def index(self, item: Node) -> int: ...
    def is_not_default(self, key: str) -> bool: ...
    def update_basic_atts(self, dict_: Union[Node, dict]) -> None: ...
    def append_attr_list(self, attr: str, values: Iterable[Any]) -> None: ...
    def pformat(self, indent: str = ..., level: int = ...) -> str: ...
    def copy(self) -> Element: ...
    def deepcopy(self) -> Element: ...
    def set_class(self, name: Any) -> None: ...
    referenced: bool
    def note_referenced_by(self, name: Optional[Any] = ..., id: Optional[Any] = ...) -> None: ...
    @classmethod
    def is_not_list_attribute(cls, attr: str) -> bool: ...
    @classmethod
    def is_not_known_attribute(cls, attr: str) -> bool: ...

class TextElement(Element):
    child_text_separator: str = ...
    def __init__(
        self, rawsource: str = ..., text: str = ..., *children: Iterable[Union[Text, Inline]], **attributes: Dict[str, Any]
    ) -> None: ...

class FixedTextElement(TextElement):
    def __init__(
        self, rawsource: str = ..., text: str = ..., *children: Iterable[Union[Text, Inline]], **attributes: Dict[str, Any]
    ) -> None: ...

class Resolvable:
    resolved: bool

class BackLinkable:
    def add_backref(self, refid: Any) -> None: ...

class Root: ...
class Titular: ...
class PreBibliographic: ...
class Bibliographic: ...
class Decorative(PreBibliographic): ...
class Structural: ...
class Body: ...
class General(Body): ...
class Sequential(Body): ...
class Admonition(Body): ...
class Special(Body): ...
class Invisible(PreBibliographic): ...
class Part: ...
class Inline: ...
class Referential(Resolvable): ...

class Targetable(Resolvable):
    referenced: bool
    indirect_reference_name: Optional[str]

class Labeled: ...

class document(Root, Structural, Element):
    current_source: Optional[str]
    current_line: Optional[int]
    indirect_targets: Sequence[Node]
    transform_messages: Any = ...
    transformer: Transformer
    document: document
    def copy(self): ...
    def get_decoration(self) -> decoration: ...

class title(Titular, PreBibliographic, TextElement): ...
class subtitle(Titular, PreBibliographic, TextElement): ...
class rubric(Titular, TextElement): ...
class docinfo(Bibliographic, Element): ...
class author(Bibliographic, TextElement): ...
class authors(Bibliographic, Element): ...
class organization(Bibliographic, TextElement): ...
class address(Bibliographic, FixedTextElement): ...
class contact(Bibliographic, TextElement): ...
class version(Bibliographic, TextElement): ...
class revision(Bibliographic, TextElement): ...
class status(Bibliographic, TextElement): ...
class date(Bibliographic, TextElement): ...
class copyright(Bibliographic, TextElement): ...

class decoration(Decorative, Element):
    def get_header(self) -> Node: ...
    def get_footer(self) -> Node: ...

class header(Decorative, Element): ...
class footer(Decorative, Element): ...
class section(Structural, Element): ...
class topic(Structural, Element): ...
class sidebar(Structural, Element): ...
class transition(Structural, Element): ...
class paragraph(General, TextElement): ...
class compound(General, Element): ...
class container(General, Element): ...
class bullet_list(Sequential, Element): ...
class enumerated_list(Sequential, Element): ...
class list_item(Part, Element): ...
class definition_list(Sequential, Element): ...
class definition_list_item(Part, Element): ...
class term(Part, TextElement): ...
class classifier(Part, TextElement): ...
class definition(Part, Element): ...
class field_list(Sequential, Element): ...
class field(Part, Element): ...
class field_name(Part, TextElement): ...
class field_body(Part, Element): ...

class option(Part, Element):
    child_text_separator: str

class option_argument(Part, TextElement):
    def astext(self) -> str: ...

class option_group(Part, Element):
    child_text_separator: str

class option_list(Sequential, Element): ...

class option_list_item(Part, Element):
    child_text_separator: str

class option_string(Part, TextElement): ...
class description(Part, Element): ...
class literal_block(General, FixedTextElement): ...
class doctest_block(General, FixedTextElement): ...
class math_block(General, FixedTextElement): ...
class line_block(General, Element): ...

class line(Part, TextElement):
    indent: Optional[str]

class block_quote(General, Element): ...
class attribution(Part, TextElement): ...
class attention(Admonition, Element): ...
class caution(Admonition, Element): ...
class danger(Admonition, Element): ...
class error(Admonition, Element): ...
class important(Admonition, Element): ...
class note(Admonition, Element): ...
class tip(Admonition, Element): ...
class hint(Admonition, Element): ...
class warning(Admonition, Element): ...
class admonition(Admonition, Element): ...
class comment(Special, Invisible, FixedTextElement): ...
class substitution_definition(Special, Invisible, TextElement): ...
class target(Special, Invisible, Inline, TextElement, Targetable): ...
class footnote(General, BackLinkable, Element, Labeled, Targetable): ...
class citation(General, BackLinkable, Element, Labeled, Targetable): ...
class label(Part, TextElement): ...
class figure(General, Element): ...
class caption(Part, TextElement): ...
class legend(Part, Element): ...
class table(General, Element): ...
class tgroup(Part, Element): ...
class colspec(Part, Element): ...
class thead(Part, Element): ...
class tbody(Part, Element): ...
class row(Part, Element): ...
class entry(Part, Element): ...

class system_message(Special, BackLinkable, PreBibliographic, Element):
    def __init__(self, message: Optional[str] = ..., *children: Iterable[Node], **attributes: Dict[str, Any]) -> None: ...
    def astext(self) -> str: ...

class pending(Special, Invisible, Element):
    transform: Transform
    details: dict
    def __init__(
        self,
        transform: Transform,
        details: Optional[Any] = ...,
        rawsource: str = ...,
        *children: Iterable[Node],
        **attributes: Dict[str, Any],
    ) -> None: ...
    def pformat(self, indent: str = ..., level: int = ...) -> str: ...
    def copy(self) -> pending: ...

class raw(Special, Inline, PreBibliographic, FixedTextElement): ...
class emphasis(Inline, TextElement): ...
class strong(Inline, TextElement): ...
class literal(Inline, TextElement): ...
class reference(General, Inline, Referential, TextElement): ...
class footnote_reference(Inline, Referential, TextElement): ...
class citation_reference(Inline, Referential, TextElement): ...
class substitution_reference(Inline, TextElement): ...
class title_reference(Inline, TextElement): ...
class abbreviation(Inline, TextElement): ...
class acronym(Inline, TextElement): ...
class superscript(Inline, TextElement): ...
class subscript(Inline, TextElement): ...
class math(Inline, TextElement): ...

class image(General, Inline, Element):
    def astext(self) -> str: ...

class inline(Inline, TextElement): ...
class problematic(Inline, TextElement): ...
class generated(Inline, TextElement): ...

node_class_names: List[str]

class NodeVisitor:
    optional: Tuple[str, ...]
    document: document
    def __init__(self, document) -> None: ...
    def dispatch_visit(self, node: Node): ...
    def dispatch_departure(self, node: Node): ...
    def unknown_visit(self, node: Node) -> None: ...
    def unknown_departure(self, node: Node) -> None: ...

class SparseNodeVisitor(NodeVisitor): ...

class GenericNodeVisitor(NodeVisitor):
    def default_visit(self, node: Node) -> None: ...
    def default_departure(self, node: Node) -> None: ...

class TreeCopyVisitor(GenericNodeVisitor):
    parent_stack: Sequence[Node]
    def __init__(self, document: document) -> None: ...
    def default_visit(self, node: Node) -> None: ...
    def default_departure(self, node: Node) -> None: ...

class TreePruningException(Exception): ...
class SkipChildren(TreePruningException): ...
class SkipSiblings(TreePruningException): ...
class SkipNode(TreePruningException): ...
class SkipDeparture(TreePruningException): ...
class NodeFound(TreePruningException): ...
class StopTraversal(TreePruningException): ...

def make_id(string: str) -> str: ...
def dupname(node: Node, name: str) -> None: ...
def fully_normalize_name(name: str) -> str: ...
def whitespace_normalize_name(name: str) -> str: ...
def serial_escape(value: str) -> str: ...
def pseudo_quoteattr(value: str) -> str: ...
def __getattr__(name: str) -> Any: ...  # incomplete
